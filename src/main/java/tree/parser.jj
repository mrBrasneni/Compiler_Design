/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. parser.jj */
/*@egen*/options {
                          
                 
                             
    OUTPUT_DIRECTORY = "../parser";
                                             
}

PARSER_BEGIN(Parser)


//package tree;
//import parser.Parser;

package parser;
import tree.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/

}
PARSER_END(Parser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
|   <SINGLE_LINE_COMMENT : "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")? >
|   <MULTI_LINE_COMMENT : "/*" (~["*"] | "*" ~["/"])* "*/" >
}

/** Reserved words. */
TOKEN : {
    <BOOLEAN : "boolean">
|   <CLASS : "class">
|   <ELSE : "else">
|   <EXTENDS: "extends">
|   <FALSE: "false">
|   <IF: "if">
|   <INT: "int">
|   <LENGTH : "length">
|   <MAIN : "main">
|   <NEW: "new">
|   <PUBLIC : "public">
|   <RETURN: "return">
|   <STATIC: "static">
|   <STRING : "String">
|   <SOP : "System.out.println">
|   <THIS: "this">
|   <TRUE: "true">
|   <VOID: "void">
|   <WHILE: "while">
}

/** Literals. */
TOKEN : {
    <INTEGER_LITERAL : ["0" - "9"](["0" - "9"])*>
|   <STRING_LITERAL : "\"" (~["\"","\\","\n","\r"])* "\"">
}

/** Identifiers. */
TOKEN : {
    <ID : ["_","a" - "z","A" - "Z"](["_","a" - "z","A" - "Z","0" - "9"])*>
}

/** Separators. */
TOKEN : {
    <LPAR : "(">
|   <RPAR : ")">
|   <LBRACE : "{">
|   <RBRACE : "}">
|   <LBRACKET : "[">
|   <RBRACKET : "]">
|   <SEMICOLON : ";">
|   <COMMA : ",">
|   <DOT : ".">
}

/** Operators. */
TOKEN : {
    <ASSIGN : "=">
|   <EQUALS : "==">
|   <NOTEQ : "!=">
|   <GT : ">">
|   <GTEQ : ">=">
|   <LESS : "<">
|   <LESSEQ : "<=">
|   <NOT : "!">
|   <OR : "||">
|   <AND : "&&">
|   <PLUS : "+">
|   <MINUS : "-">
|   <MUL : "*">
|   <DIV : "/">
}


ASTProgram Program()         :
{/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    MainClass() (ClassDecl())*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Identifier()            :
{/*@bgen(jjtree) Identifier */
    ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    t=<ID>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(t.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

void MainClass()           :
{/*@bgen(jjtree) MainClass */
  ASTMainClass jjtn000 = new ASTMainClass(JJTMAINCLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) MainClass */
    try {
/*@egen*/
    <CLASS> Identifier() <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LBRACKET> <RBRACKET>  Identifier() <RPAR> <LBRACE>
            (Statement())*
        <RBRACE>
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassDecl()           :
{/*@bgen(jjtree) ClassDecl */
  ASTClassDecl jjtn000 = new ASTClassDecl(JJTCLASSDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ClassDecl */
    try {
/*@egen*/
    <CLASS> Identifier()/*@bgen(jjtree) Inheritance */
                         {
                           ASTInheritance jjtn001 = new ASTInheritance(JJTINHERITANCE);
                           boolean jjtc001 = true;
                           jjtree.openNodeScope(jjtn001);
                         }
                         try {
/*@egen*/ (<EXTENDS> Identifier() )?/*@bgen(jjtree)*/
                         } catch (Throwable jjte001) {
                           if (jjtc001) {
                             jjtree.clearNodeScope(jjtn001);
                             jjtc001 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte001 instanceof RuntimeException) {
                             throw (RuntimeException)jjte001;
                           }
                           if (jjte001 instanceof ParseException) {
                             throw (ParseException)jjte001;
                           }
                           throw (Error)jjte001;
                         } finally {
                           if (jjtc001) {
                             jjtree.closeNodeScope(jjtn001, true);
                           }
                         }
/*@egen*/              <LBRACE>
         (/*@bgen(jjtree) VarDecls */
          {
            ASTVarDecls jjtn002 = new ASTVarDecls(JJTVARDECLS);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/((VarDecl())*)/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002, true);
            }
          }
/*@egen*/          )
         (/*@bgen(jjtree) MethodDecls */
          {
            ASTMethodDecls jjtn003 = new ASTMethodDecls(JJTMETHODDECLS);
            boolean jjtc003 = true;
            jjtree.openNodeScope(jjtn003);
          }
          try {
/*@egen*/(MethodDecl()) */*@bgen(jjtree)*/
          } catch (Throwable jjte003) {
            if (jjtc003) {
              jjtree.clearNodeScope(jjtn003);
              jjtc003 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte003 instanceof RuntimeException) {
              throw (RuntimeException)jjte003;
            }
            if (jjte003 instanceof ParseException) {
              throw (ParseException)jjte003;
            }
            throw (Error)jjte003;
          } finally {
            if (jjtc003) {
              jjtree.closeNodeScope(jjtn003, true);
            }
          }
/*@egen*/             )
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDecl()         :
{/*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecl */
    try {
/*@egen*/
    Type() Identifier() <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethodDecl()            :
{/*@bgen(jjtree) MethodDecl */
  ASTMethodDecl jjtn000 = new ASTMethodDecl(JJTMETHODDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodDecl */
    try {
/*@egen*/
    <PUBLIC> Type() Identifier() <LPAR> (/*@bgen(jjtree) Args */
                                         {
                                           ASTArgs jjtn001 = new ASTArgs(JJTARGS);
                                           boolean jjtc001 = true;
                                           jjtree.openNodeScope(jjtn001);
                                         }
                                         try {
/*@egen*/FormalList()/*@bgen(jjtree)*/
                                         } catch (Throwable jjte001) {
                                           if (jjtc001) {
                                             jjtree.clearNodeScope(jjtn001);
                                             jjtc001 = false;
                                           } else {
                                             jjtree.popNode();
                                           }
                                           if (jjte001 instanceof RuntimeException) {
                                             throw (RuntimeException)jjte001;
                                           }
                                           if (jjte001 instanceof ParseException) {
                                             throw (ParseException)jjte001;
                                           }
                                           throw (Error)jjte001;
                                         } finally {
                                           if (jjtc001) {
                                             jjtree.closeNodeScope(jjtn001, true);
                                           }
                                         }
/*@egen*/      ) <RPAR> <LBRACE>
        (LOOKAHEAD(2) VarDecl())* (Statement())* <RETURN> Exp() <SEMICOLON>
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FormalList():
{}
{
    ((/*@bgen(jjtree) Arg */
      {
        ASTArg jjtn001 = new ASTArg(JJTARG);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
      }
      try {
/*@egen*/(Type() Identifier())/*@bgen(jjtree)*/
      } catch (Throwable jjte001) {
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte001 instanceof RuntimeException) {
          throw (RuntimeException)jjte001;
        }
        if (jjte001 instanceof ParseException) {
          throw (ParseException)jjte001;
        }
        throw (Error)jjte001;
      } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001, true);
        }
      }
/*@egen*/     )  (FormalRest())*)?
}

void FormalRest():
{}
{
    <COMMA> (/*@bgen(jjtree) Arg */
             {
               ASTArg jjtn001 = new ASTArg(JJTARG);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
             }
             try {
/*@egen*/(Type() Identifier())/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001, true);
               }
             }
/*@egen*/     )
}

void Type()      :
{/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ ASTIdentifier n;}
{/*@bgen(jjtree) Type */
     try {
/*@egen*/
     (<INT> {jjtn000.setType("int");}
|   <BOOLEAN> {jjtn000.setType("boolean");}
|   Identifier()
        {
            n = (ASTIdentifier)jjtree.popNode();
            jjtn000.setType(n.getName());
        }
    )
    (<LBRACKET> <RBRACKET>{jjtn000.setVector(true);})?/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

//void TypeArray() #TypeArray:
//{}
//{
//    <LBRACKET> <RBRACKET>
//}

void Statement():
{}
{
    <LBRACE> (Statement())* <RBRACE>
|   <IF> <LPAR> Exp() <RPAR> Statement() <ELSE> Statement()
|   <WHILE> <LPAR> Exp() <RPAR> Statement()
|   <SOP> <LPAR> Exp() <RPAR>  <SEMICOLON>
|   LOOKAHEAD(2) <ID> <ASSIGN>  Exp() <SEMICOLON>
|   LOOKAHEAD(2) <ID> <LBRACKET> Exp() <RBRACKET> <ASSIGN>  Exp() <SEMICOLON>
|   VarDecl()
}

void Exp():
{}
{
    ExpLogic()
}

void ExpLogic():
{}
{
    ExpRel() ((<AND> | <OR> ) ExpRel())*
}

void ExpRel():
{}
{
    ExpAdd() ((<GT> | <GTEQ> | <LESS> | <LESSEQ> | <EQUALS> | <NOTEQ> ) ExpAdd())*
}

void ExpAdd():
{}
{
    ExpMul() ((<PLUS> | <MINUS> ) ExpMul())*
}

void ExpMul():
{}
{
    ExpUnary() ((<MUL> | <DIV> ) ExpUnary())*
}

void ExpUnary():
{}
{
    (<MINUS> | <NOT>)?
    ExpPostfix()
}

void ExpPostfix():
{}
{
    ExpFactor() (<LBRACKET> Exp() <RBRACKET>
                | LOOKAHEAD(2) <DOT> <ID> (<LPAR> ExpList() <RPAR>)?
                | <DOT> <LENGTH> )*
}

void ExpFactor():
{}
{
    <INTEGER_LITERAL>
|   <TRUE>
|   <FALSE>
|   <ID>
|   <THIS>
|   <LPAR> Exp() <RPAR>
|   LOOKAHEAD(2) <NEW> <INT> <LBRACKET> Exp() <RBRACKET>
|   <NEW> <ID> <LPAR> <RPAR>
}

void ExpList():
{}
{
    (Exp() (ExpRest())*)?
}

void ExpRest():
{}
{
    <COMMA> Exp()
}