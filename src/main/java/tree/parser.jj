/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. parser.jj */
/*@egen*/options {
                          
                 
                             
    OUTPUT_DIRECTORY = "../parser";
                                             
}

PARSER_BEGIN(Parser)


//package tree;
//import parser.Parser;

package parser;
import tree.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/

}
PARSER_END(Parser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
|   <SINGLE_LINE_COMMENT : "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")? >
|   <MULTI_LINE_COMMENT : "/*" (~["*"] | "*" ~["/"])* "*/" >
}

/** Reserved words. */
TOKEN : {
    <BOOLEAN : "boolean">
|   <CLASS : "class">
|   <ELSE : "else">
|   <EXTENDS: "extends">
|   <FALSE: "false">
|   <IF: "if">
|   <INT: "int">
|   <LENGTH : "length">
|   <MAIN : "main">
|   <NEW: "new">
|   <PUBLIC : "public">
|   <RETURN: "return">
|   <STATIC: "static">
|   <STRING : "String">
|   <SOP : "System.out.println">
|   <THIS: "this">
|   <TRUE: "true">
|   <VOID: "void">
|   <WHILE: "while">
}

/** Literals. */
TOKEN : {
    <INTEGER_LITERAL : ["0" - "9"](["0" - "9"])*>
|   <STRING_LITERAL : "\"" (~["\"","\\","\n","\r"])* "\"">
}

/** Identifiers. */
TOKEN : {
    <ID : ["_","a" - "z","A" - "Z"](["_","a" - "z","A" - "Z","0" - "9"])*>
}

/** Separators. */
TOKEN : {
    <LPAR : "(">
|   <RPAR : ")">
|   <LBRACE : "{">
|   <RBRACE : "}">
|   <LBRACKET : "[">
|   <RBRACKET : "]">
|   <SEMICOLON : ";">
|   <COMMA : ",">
|   <DOT : ".">
}

/** Operators. */
TOKEN : {
    <ASSIGN : "=">
|   <EQUALS : "==">
|   <NOTEQ : "!=">
|   <GT : ">">
|   <GTEQ : ">=">
|   <LESS : "<">
|   <LESSEQ : "<=">
|   <NOT : "!">
|   <OR : "||">
|   <AND : "&&">
|   <PLUS : "+">
|   <MINUS : "-">
|   <MUL : "*">
|   <DIV : "/">
}


ASTProgram Program()         :
{/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    MainClass() (ClassDecl())*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MainClass()           :
{/*@bgen(jjtree) MainClass */
    ASTMainClass jjtn000 = new ASTMainClass(JJTMAINCLASS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) MainClass */
    try {
/*@egen*/
    <CLASS> t=<ID> <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LBRACKET> <RBRACKET>  <ID> <RPAR> <LBRACE>
            (Statement())*
        <RBRACE>
    <RBRACE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(t.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassDecl()           :
{/*@bgen(jjtree) ClassDecl */
    ASTClassDecl jjtn000 = new ASTClassDecl(JJTCLASSDECL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) ClassDecl */
    try {
/*@egen*/
    <CLASS> t=<ID> (<EXTENDS> <ID> )? <LBRACE>
         (VarDecl())*
         (MethodDecl()) *
    <RBRACE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(t.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDecl()            :
{/*@bgen(jjtree) #VarDecl( 1) */
    ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) #VarDecl( 1) */
    try {
/*@egen*/
    Type() t=<ID> <SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000,  1);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(t.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  1);
      }
    }
/*@egen*/
}

void MethodDecl()            :
{/*@bgen(jjtree) MethodDecl */
  ASTMethodDecl jjtn000 = new ASTMethodDecl(JJTMETHODDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodDecl */
    try {
/*@egen*/
    <PUBLIC> Type() <ID> <LPAR> FormalList() <RPAR> <LBRACE>
        (LOOKAHEAD(2) VarDecl())* (Statement())* <RETURN> Exp() <SEMICOLON>
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FormalList():
{}
{
    (Type() <ID>  (FormalRest())*)?
}

void FormalRest():
{}
{
    <COMMA> Type() <ID>
}

void Type()      :
{/*@bgen(jjtree) Type */
    ASTType jjtn000 = new ASTType(JJTTYPE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Type */
     try {
/*@egen*/
     (<INT> {jjtn000.setType("int");}
|   <BOOLEAN> {jjtn000.setType("boolean");}
|   t=<ID> {jjtn000.setType(t.image);}) (<LBRACKET> <RBRACKET>{jjtn000.setVector(true);})?/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

//void TypeArray() #TypeArray:
//{}
//{
//    <LBRACKET> <RBRACKET>
//}

void Statement():
{}
{
    <LBRACE> (Statement())* <RBRACE>
|   <IF> <LPAR> Exp() <RPAR> Statement() <ELSE> Statement()
|   <WHILE> <LPAR> Exp() <RPAR> Statement()
|   <SOP> <LPAR> Exp() <RPAR>  <SEMICOLON>
|   LOOKAHEAD(2) <ID> <ASSIGN>  Exp() <SEMICOLON>
|   LOOKAHEAD(2) <ID> <LBRACKET> Exp() <RBRACKET> <ASSIGN>  Exp() <SEMICOLON>
|   VarDecl()
}

void Exp():
{}
{
    ExpLogic()
}

void ExpLogic():
{}
{
    ExpRel() ((<AND> | <OR> ) ExpRel())*
}

void ExpRel():
{}
{
    ExpAdd() ((<GT> | <GTEQ> | <LESS> | <LESSEQ> | <EQUALS> | <NOTEQ> ) ExpAdd())*
}

void ExpAdd():
{}
{
    ExpMul() ((<PLUS> | <MINUS> ) ExpMul())*
}

void ExpMul():
{}
{
    ExpUnary() ((<MUL> | <DIV> ) ExpUnary())*
}

void ExpUnary():
{}
{
    (<MINUS> | <NOT>)?
    ExpPostfix()
}

void ExpPostfix():
{}
{
    ExpFactor() (<LBRACKET> Exp() <RBRACKET>
                | LOOKAHEAD(2) <DOT> <ID> (<LPAR> ExpList() <RPAR>)?
                | <DOT> <LENGTH> )*
}

void ExpFactor():
{}
{
    <INTEGER_LITERAL>
|   <TRUE>
|   <FALSE>
|   <ID>
|   <THIS>
|   <LPAR> Exp() <RPAR>
|   LOOKAHEAD(2) <NEW> <INT> <LBRACKET> Exp() <RBRACKET>
|   <NEW> <ID> <LPAR> <RPAR>
}

void ExpList():
{}
{
    (Exp() (ExpRest())*)?
}

void ExpRest():
{}
{
    <COMMA> Exp()
}