options {
    DEBUG_PARSER = true;
    OUTPUT_DIRECTORY = "../java/parser";
}

PARSER_BEGIN(Parser)

package parser;

public class Parser {

}
PARSER_END(Parser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

/** Reserved words. */
TOKEN : {
    <BOOLEAN : "boolean">
|   <CLASS : "class">
|   <ELSE : "else">
|   <EXTENDS: "extends">
|   <FALSE: "false">
|   <IF: "if">
|   <INT: "int">
|   <LENGTH : "length">
|   <MAIN : "main">
|   <NEW: "new">
|   <PUBLIC : "public">
|   <RETURN: "return">
|   <STATIC: "static">
|   <STRING : "String">
|   <SOP : "System.out.println">
|   <THIS: "this">
|   <TRUE: "true">
|   <VOID: "void">
|   <WHILE: "while">
}

/** Literals. */
TOKEN : {
    <INTEGER_LITERAL : ["1" - "9"](["0" - "9"])*>
|   <STRING_LITERAL : "\"" (~["\"","\\","\n","\r"])* "\"">
}

/** Identifiers. */
TOKEN : {
    <ID : ["_","a" - "z","A" - "Z"](["_","a" - "z","A" - "Z","0" - "9"])*>
}

/** Separators. */
TOKEN : {
    <LPAR : "(">
|   <RPAR : ")">
|   <LBRACE : "{">
|   <RBRACE : "}">
|   <LBRACKET : "[">
|   <RBRACKET : "]">
|   <SEMICOLON : ";">
|   <COMMA : ",">
|   <DOT : ".">
}

/** Operators. */
TOKEN : {
    <ASSIGN : "=">
|   <MINUS : "-">
|   <EQUALS : "==">
|   <GT : ">">
|   <GTEQ : ">=">
|   <LESS : "<">
|   <LESSEQ : "<=">
|   <NOT : "!">
}


void Program():
{}
{
    MainClass() (ClassDecl())*
}

void MainClass():
{}
{
    <CLASS> <ID> <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LBRACKET> <RBRACKET>  <ID> <RPAR> <LBRACE>
//            Statement()
        <RBRACE>
    <RBRACE>
}

void ClassDecl():
{}
{
//    (<CLASS> <ID> <LBRACE>
////        (VarDecl() | MethodDecl()) *
//    <RBRACE>)
//|
    <CLASS> <ID> (<EXTENDS> <ID> )? <LBRACE>
         (VarDecl()
         |
         MethodDecl()) *
    <RBRACE>
}

void VarDecl():
{}
{
    Type() <ID> <SEMICOLON>
}

void MethodDecl():
{}
{
    <PUBLIC> Type() <ID> <LPAR> FormalList() <RPAR> <LBRACE>
        (VarDecl())* (Statement())* <RETURN> Exp() <SEMICOLON>
    <RBRACE>
}

void FormalList():
{}
{
    (Type() <ID>  (FormalRest())*)?
}

void FormalRest():
{}
{
    <COMMA> Type() <ID>
}

void Type():
{}
{
    <INT> <LBRACKET> <RBRACKET>
|   <BOOLEAN>
|   <INT>
|   <ID>
}

void Statement():
{}
{
    (Statement())* //recusrivitate de stanga
|   <IF> <LPAR> Exp() <RPAR> Statement() <ELSE> Statement()
|   <WHILE> <LPAR> Exp() <RPAR> Statement()
|   <SOP> <LPAR> Exp() <RPAR>  <SEMICOLON>
|   <ID> <ASSIGN>  Exp() <SEMICOLON>
|   <ID> <LBRACKET> Exp() <RBRACKET> <ASSIGN>  Exp() <SEMICOLON>
}

void Exp():
{}
{
    Exp() <OP> Exp()
|   Exp() <LBRACKET>  Exp() <RBRACKET>
|   Exp() <DOT> <LENGTH>
|   Exp() <DOT> <ID> <LPAR> ExpList() <RPAR>
|   <INTEGER_LITERAL>
|   <TRUE>
|   <FALSE>
|   <ID>
|   <THIS>
|   <NEW> <INT> <LBRACKET> Exp() <RBRACKET>
|   <NEW> <ID> <LPAR> <RPAR>
|   <NOT> Exp()
|   <LPAR> Exp() <RPAR>
}

void ExpList():
{}
{
    (Exp() (ExpRest())*)?
}

void ExpRest():
{}
{
    <COMMA> Exp()
}


